// 맥주 마시면서 걸어가기
#include <iostream>
#include <vector>
#include <queue>
#define MAX_VAL 101

using namespace std;

int n, end_x, end_y;
bool flg;
bool visited[MAX_VAL];
vector<pair<int, int>> con_info;

/*
거리 계산 식
dx + dy
최대 진행 가능 거리 1000
*/

void dfs(int now_x, int now_y) {
    // 수정 필요
    if (abs(now_x - end_x) + abs(now_y-end_y) <= 1000) {
        flg = true;
        return ;
    }

    for (int i=0; i<con_info.size(); i++) {
        if (!visited[i] && !flg) {
            int dx, dy;
            if (now_x * con_info[i].first < 0) {
                dx = abs(now_x + con_info[i].first);
            }
            else dx = abs(now_x - con_info[i].first);
            if (now_y * con_info[i].second < 0) {
                dy = abs(now_y + con_info[i].second);
            }
            else dy = abs(now_y - con_info[i].second);

            if (dx + dy <= 1000) {
                visited[i] = true;
                dfs(con_info[i].first, con_info[i].second);
                visited[i] = false; 
            }
        }
    }
}

/*
1
96
-1260 2266
2768 -901
-3560 2208
3064 -2583
1019 1354
2789 3653
409 -1157
1353 975
228 -2583
-801 2918
-3052 -1178
-777 -3291
-2535 1836
-3397 -3762
-603 -617
-2907 -1058
-1327 1008
199 3358
-1326 3453
1636 -470
3206 635
-2720 547
-3660 -2876
1228 -2266
-3376 936
-1096 1398
-1906 1249
2226 1972
254 -3373
3566 141
-1135 -596
-2231 -308
-13 -1520
-3118 -199
-1137 -2805
-2720 2951
-3636 -1403
2816 -1769
-276 873
2241 3190
1789 -2469
2485 -1435
-2997 -2914
1100 1730
3346 307
-3569 330
-290 1634
2550 1921
-2415 2533
3480 1538
260 3587
643 691
3730 -729
2783 -2164
1016 3446
2771 -1718
-1773 -2480
-1959 1877
980 -1631
-986 -3020
778 -2800
2123 3107
-2288 -3540
-1379 -3210
1475 -3532
-2341 2760
2696 2070
2852 2813
2617 2873
743 3050
-3323 1294
-2106 2129
-1965 2851
1108 -2255
268 3000
-2059 -1528
-2550 3571
907 -1375
859 1344
-1795 -310
-20 3180
-1171 1489
451 2527
2111 3699
-1476 -1679
-1159 -128
896 1590
2266 -2095
3530 -2567
-997 3345
-850 -1679
-1577 346
3195 3379
2140 -3184
-3693 -23
-2205 3271
3296 687
2990 1662

sad

2
87
-3212 -1334
-202 -1822
3382 1775
3442 175
-933 -3420
291 505
686 -1534
-2765 1988
-810 -2439
-1729 -2660
-3321 -2553
-587 -2219
1758 -299
642 1884
-3280 -1447
-661 2758
-2205 -661
3612 -2591
-2542 3429
810 3546
-3679 3062
416 1288
-689 -650
-3243 694
-3113 3201
-179 1980
2913 1991
-3649 -2432
219 1833
838 -2188
730 3400
2930 2090
-2348 -533
1157 -1726
-758 2564
-1243 3433
-2227 1871
-3622 3590
-780 3751
1141 -854
-1932 2299
-1635 2375
2037 3190
331 1268
-849 -3474
-3115 -65
751 1220
3225 -2839
1535 3506
-3120 627
-2338 -198
-2949 -2656
489 3040
-1627 -1119
72 3267
-1276 1424
3247 -2601
1194 -505
1396 -2927
-3631 148
6 1126
-3494 -839
-1109 2831
-816 2847
838 -3159
2241 -3208
737 -1940
-125 2787
-3075 275
1922 -2855
2114 -2378
-327 -1939
311 2850
-2246 1942
2880 -3170
961 807
-1967 2297
-3742 229
-3696 -1363
-1779 -657
-1443 3082
1884 -118
1447 -2206
-2689 -1824
1773 -128
-85 -649
658 656
-1951 -1344
3598 497
75
-31 -2879
-2710 3217
2155 2540
3486 407
-1739 2781
3057 1457
-523 -1328
297 2347
2506 2126
-923 3038
668 -1011
-1911 1950
-2757 2062
3487 -3470
1962 -3337
2547 764
3316 2178
-3141 -2882
3123 -3175
-1233 -3390
-457 1905
-2119 -3053
-2403 -979
-3295 -2375
2254 535
3056 566
-934 -3758
642 -1201
-1234 -2281
3231 -2517
-1234 394
1669 -2037
2639 1567
-1033 -2368
-3263 1050
-1706 -104
2277 -3146
-914 535
-3539 -2984
-2926 1570
2705 550
930 1447
3178 -1631
-1147 -2694
-654 3256
2777 3645
-2876 -3185
1454 -782
905 -3360
577 -530
-179 -90
-2809 1746
847 1312
345 608
-697 -1445
-3361 -481
-628 1424
-438 798
-1775 -542
-2144 1971
-1789 614
-2965 -2805
-2766 -1759
1516 -71
3681 -3492
3703 -352
-3171 288
1054 659
794 -374
3445 3583
-63 243
622 2367
-1324 -3478
-2405 1152
-602 -2819
2955 -3691
-3583 -310

sad / sad
*/

void bfs(int x, int y) {
    queue<pair<int, int>> q;
    q.push(make_pair(x, y));

    while (!q.empty()) {
        int dx, dy;
        x = q.front().first;
        y = q.front().second;
        q.pop();

        dx = x*end_x < 0 ? abs(x + end_x) : abs(x - end_x);
        dy = y*end_y < 0 ? abs(y + end_y) : abs(y - end_y);
        if (dx + dy <= 1000) {
            flg=true;
            break;
        }

        for (int i=0; i<con_info.size(); i++) {
            dx = x*con_info[i].first < 0 ? abs(x + con_info[i].first) : abs(x - con_info[i].first);
            dy = y*con_info[i].second < 0 ? abs(y + con_info[i].second) : abs(y - con_info[i].second);
            if (dx + dy <= 1000 && !visited[i]) { 
                q.push(make_pair(con_info[i].first, con_info[i].second));
                visited[i] = true;
            }                    
        }

    }
}

void init () {
    con_info.clear();
    flg = false;
    for (int i=0; i<=n; i++) {
        visited[i] = false;
    }
}

int main () {
    ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);

    int test_case;

    cin >> test_case;
    for (int tc=1; tc<=test_case; tc++) {
        int start_x, start_y;

        // init
        init();

        // input
        cin >> n;
        cin >> start_x >> start_y;
        int tmp_x, tmp_y;
        for (int i=0; i<n; i++) {
            cin >> tmp_x >> tmp_y;
            con_info.push_back(make_pair(tmp_x, tmp_y));
        }
        cin >> end_x >> end_y;

        bfs(start_x, start_y);

        // output
        if (flg) cout << "happy" << "\n";
        else cout << "sad" << "\n";
    }

    return 0;
}